스택은 이러한 **후입선출**이라 불리는 **LIFO(Last In First Out)**으로 마지막에 들어간놈이→먼저나간다로 이해하시면됩니다.

즉 스택은 자료를 담아두는 자료형이며 들어가면 순서대로 차곡차곡 쌓여서 나갈때는 역순으로 빠져나가는 자료형이라고 생각하시면됩니다.



상자의 사진을 예시로든건 이와 같습니다. 예를 들어 입구가 하나인 상자에 책을 차곡차곡 쌓는다고 생각해보세요.

그럼 넣는건 순서대로 넣지만 뺄때는 젤 위에서부터 빼야하죠. 만약 젤 아래에 있는 책이 필요하다면 모든 책을 꺼내야합니다.



그리고 스택이란 자료형은 솔직히 말하면 안에 무슨 자료를 넣는지에는 조금도 관심이 없습니다.

즉 우리가 이사갈때 박스에 책을 우겨넣잖아요.

그런데 이때 순서대로 박스에 책을 넣나요. ~~일단 책을 안읽는다는 대전제는 빼놓고 생각하자~~

그렇지 않죠 어짜피 이사갈때 박스의 역활은 그냥 짐을 나르는것 뿐입니다. 즉 마구잡이로 넣죠.

거기에 무슨책을 얼마나 채계적으로 넣을지는 조금도 고려하지않습니다. 일단 넣고 보죠.

이삿짐 풀때도 마찬가집니다. 걍 빼고 보는거죠. 위에서부터 빼는겁니다.

사실 위에서 부터 뺄수밖에 없습니다. 상자를 쪼개서 억지로 밑에서 빼지 않는한

무조건 위에서 부터 뺄 수 밖에 없죠.



스택이란 자료형은 자료가 순서대로 저장되지만 빼낼때는 역순으로 마지막에 넣은 자료부터 빼내게되며

애당초 자료의 무더기라는 정보와 제일위의 자료가 먼지만 알뿐 중간의 내용물은 확인할 수 없으며

정 확인하고 싶으면 모조리 빼내야되는 그러한 자료형을 의미합니다.



![img](https://mblogthumb-phinf.pstatic.net/20151008_100/justkukaro_1444298344071eMkgT_PNG/300px-Data_stack.svg.png?type=w2)

**<출처-위키피디아>**

그림으로 표현하면 다음과 같습니다.



기술적으로 설명을 하자면 일단 **top이라는 제일 위를 가르치는 포인터가 존재합니다.**

무조건 top을 활용하여 데이터를 빼내거나 삽입하는게 가능하며

그 외의 경우는 존재하지 않습니다.

**사실 모든 연산이 이 top이라는 포인터를 거치게 되므로** 스택에서

top은 모든걸 하는 역활이라고 보면되죠.

배열로 스택을 구현하게 될시 포인터(여기서 말하는 포인터는 C의 포인터)가

존재치 않기 때문에 top은 사용되지 않고

level이나 size라는 이름으로 지금이 어디까지 저장됬는지를 알려주게됩니다.



**2. 스택의 용도**

스택은 다음과 같은 특색을 지닙니다.

**1-제일 위의 데이터만 알 수 있다.**

**2-그래도 이 때까지의 데이터의 갯수는 알 수 있다.**

**3-중간의 데이터는 죽었다 깨어나도 알 수 없다. 만약 알고싶다면 제일위부터 있을거라 추정되는 그 데이터 까지 모조리 꺼내야한다.**

**4-제일 처음 들어간 자료는 모든 자료를 꺼내기 전까지 확인할 수 없고 반대로 제일 마지막에 들어간 자료는 바로 꺼낼 수 있다.**



한번 스택에대해서 곰곰히 생각해보면 어찌보면 인간이 생각할 수 있는 자료더미 형태중에선 의외로 가장 쉽게 만들 수 있는 형태입니다.

가장 생각할법하고 가장 구현해볼법한거죠. 여기서 중요한건 내부 데이터를 확인할 도리가 없으므로

즉 스택의 특징은 데이터 더미라는것 말고는 없다고 볼 수 있습니다.



컴퓨터에서 가장 많이 쓰이는 자료형중에 하나라는 말이죠.

컴퓨터에는 여러가지기법이 존재하지만 복잡하지않고 단순하게 구현해야하는 문제에서 만약 무슨일이 발생했을 때 가장 먼저

처리해야할 일의 우선순위을 정할때 맨처음과 맨 끝중에서 하나를 고르라고 하면

대부분은 제일 처음에 있었던 일을 정하게 됩니다.



컴퓨터에는 **참조지역성**이라는 것이 있습니다. 여기서 복잡하게 설명안하고 참조지역성에 대해 간단히 설명하자면

**일단 한번 참조된곳은 또 참조될 확률이 굉장히 높다는 것이죠.**

그 참조지역성의 원리중에서 **시간지역성의 원리**라는것이 있는데

시간지역성은 **최근에 참조된자료가 다시 참조될 확률이 높다는겁니다.**

스택은 그 시간지역성을 최고로 활용할 수 있는 자료구조입니다.



즉 구현하기 쉽고 간단하지만 시간지역성을 활용할 수 있는여러가지 분야에서 응용되서 사용되는 추상적 자료형이라는거죠.



에를 들자면 컴퓨터 스케줄링에서도 복잡한 기법들이 사용되지만(설명하기엔 분야가 맞지 않습니다.)

기본 배이스는 스택을 깔아놓고 간다고 보시면됩니다. 즉 그 복잡한 기법들도 스택을 바탕으로 만들었다고 보시면되요.



즉 스케줄링이나 자원관리등의 여러부분에서 사용된다고 보시면됩니다.





**3. 스택의 시간 복잡도**

앞의 두 자료형과는 달리 스택은 추상적 자료구조라서 구현하는 방법에 따라 시간복잡도는 달라지게됩니다.

일단 앞의 두 자료고주였던 배열과 링크드리스트의 경우 검색,삭제,갱신,삽입이라는 4개의 과제를 쥐어드렸지만

스택은 검색이란 기능자체를 재공하지 않고 섬색이 없으니 갱신도 없습니다.



스택은 삽입과 삭제는 존재하지만 이는 항상 제일 위에서만 일어나며

삽입과 삭제외에도 다른 기능들이 존재합니다. 거기에 대해서도 알으셔야해요.



**1-push**

이름에서 부터 느껴지겠지만 ~~쑤셔~~넣어라. 즉 일반 다른 자료구조에서 add혹은 insert기능을 하는 함수입니다.

여러번 설명드렸지만 넣는 위치는 무조건 제일 마지막으로 정해져있고 그 순서를 바꿀 방법은 전혀없습니다.

따라서 push를 쓰게되면 무조건 제일 마지막에 삽입이 됩니다.



**2-pop**

빼내라. 제일 위의 데이터를 꺼내라는 겁니다.

즉 다른 자료구조의 delete와 같은데 느낌은 좀 다릅니다. delete은 삭제를 하는 메소드지만 pop은 삭제하는건 맞는데

자료를 꺼내서 한번 쓰고 삭제하는겁니다. 즉 search+delete역활을 한다고 보시면됩니다.

즉 껌을 예로 들자면 delete의 느낌은 껌뭉치에서 껌하나 뽑아서 버리는거라면 pop은 껌뭉치에서 껌 하나를 빼서 껌을 씹는다는거죠.

껌뭉치 입장에서는 어짜피 없어진건 똑같지만 그 자료를 활용했느냐 안했느냐의 차이가 있는 겁니다.



**3-peek(top)**

제일 위의 데이터를 삭제하진 말고 보여주라는 겁니다. 어찌 보면 search와 비슷할 수 있는데 이도 살짝 느낌이 다른데

스택이라는 자료구조의 특성상 자료를 사용하면 그 자료는 스택에서 배재해버립니다. 즉 pop이란 그런 느낌이죠.

그런데 peek는 제일위의 데이터를 사용하는데는 쓰지 않습니다. 그냥 진짜 순수하게 제일 위의 데이터가 먼지를 확인하는데만 씁니다.

예를 들어 마지막 데이터와 중복하는 데이터와 같은 데이터일 경우 삽입하지 않는 특수한 스택을 만든다든가 할 때 사용하는

조건을 확인하는 용도로 쓰는 함수라고 생각하시면됩니다.

즉 상자속의 책으로 예를 들자면 pop은 제일 위에있는 책을 꺼내는 거고 peek는 상자 위의 제일위에있는책이 먼지 확인만 하는거죠.



**4-empty(full)**

스택이 비어있는지를 검사하는 함수입니다. 비어있으면 true를 아니면 false를 리턴합니다.

full의 경우 스택이 다 차있는지를 검사하는 함수입니다. 다찼으면 true를 아니면 false를 리턴합니다.



**5-size(level)**

스택의 크기를 리턴합니다. 즉 얼만큼 들어있느냐를 리턴하는거죠.

사실 이건 구현하는 스택도 있고 아닌 스택도 있습니다.



하나씩 시간복잡도를 볼께요



push -> O(1)

시간 복잡도는 무조건 1입니다. 무조건 제일 위에 들어가니까 시간복잡도가 필요가 없어요.



pop -> O(1)

무조건 제일 위에걸 빼니까 시간복잡도가 상수시간이 나옵니다.



peek -> O(1)

이하 동문



empty - > O(1)

이게 널인지 아닌지만 확인해주면 됩니다. 무조건 시간복잡도가 1이 나옵니다.



size -> O(1) or O(n)

이게 스택의 구현방식에 따라 다릅니다. 만약 스택을 배열로 만들면 무조건 시간 복잡도가 1이나옵니다.

왜냐하면 배열을 만들때는 항상 level을 기재하고 있기 때문입니다. 그래야 다음 순서 배열로 접근할 수 있으니까.

그러나 리스트로 구현할 경우 내부적으로 끝에서 끝까지 운행을 끝마쳐야 level을 알 수 있습니다.

즉 이 때 시간복잡도는 O(n)이 됩니다.



**※아니 근데 꺼내지 않는 한에는 다음 자료를 확인할 수 없는 스택에서 운행이라는 개념이 있나요?**

**충분히 예상가능한 질문인데 이 운행은 스택내부에서 하는 운행이고 이는 캡슐화 되서 외부로 공개되지 않습니다.**

**즉 저희가 size라는 함수를 사용할 경우 내부에서는 운행으로 작동할지라도 외부에서는 이 과정을 확인할 수 없다는거죠.**



물론 링크드리스트로 구현할 때도 레벨을 명시적으로 밝히는 방법을 사용하면 O(1)의 시간으로 접근할 수 있습니다.

그러나 레벨 확인 용도외에는 조금도 필요가 없는 level을 명시적으로 표시하는건 살짝 껄끄럽습니다.

그만큼 오버헤드가 늘어나고 자료형의 크기가 커진다는 부담도 있음.

게다가 스택에 size연산을 쓸일이 사실은 별로 없음



```c
#include<stdbool.h >
#ifndef STACK_H
#define STACK_H
#define NUM 10

int stack[NUM];

static int level=-1;

bool stack_empty() {
    if (level == -1) return true;
    else return false;
}



bool stack_full() {
    if (level == NUM - 1) return true;
    else return false;
}



bool stack_push(int data) {
    if (stack_full()) return false;
    else {
        stack[++level] = data;
        return true;
    }
}

int stack_pop() {
    if (stack_empty()) return NULL;
    return stack[level--];
}


int stack_peek() {
    return stack[level];
}



int stack_size() {
    return level + 1;
}
```



* source code

```c
typedef struct node {
	int data;
	struct node *next;
}node;

typedef struct Stack {
	node *top;
}Stack;

void initstack(Stack *stack) {
	stack->top = NULL;
}

void Push(Stack *stack, int num) {
	node *n = (node *)malloc(sizeof(node));
	n->data = num;
	n->next = stack->top;
	stack->top = n;
}

int IsEmpty(Stack *stack) {
	return stack->top == NULL;
}

int Pop(Stack *stack) {
	node *n;
	if (IsEmpty(stack)) return -1;
	int number;
	n = stack->top;
	number = n->data;
	stack->top = n->next;
	free(n);
	return number;
}

void printstack(Stack *stack) {
	node *n;
	n = stack->top;
	printf("%d\n", n->data);
}
```





```
class stackarray
{
private:
    int *Stack;
    int Size;
    int Top;
 
public:
    void InitStack(int aSize)
    {
        Size=aSize;
        Stack=(int *)malloc(Size*sizeof(int));
        Top=-1;
    }//스택 크기 결정 함수
 
    void FreeStack()
    {
        free(Stack);
    }//스택 파괴
 
    bool Push(int data)
    {
        if (Top < Size-1)
        {
            Top++;
            Stack[Top]=data;
            return true;
        }
        else
        {
            return false;
        }
    }//데이터 저장
 
 
    int Pop()
    {
        if (Top >= 0)
        {
            return Stack[Top--];
        }
        else
        {
            return -1;
        }
    }//데이터 반환
};
 
void main()
{
    stackarray st; //객체 생성
    st.InitStack(5); //스택의 크기를 5로 지정
    st.Push(1);
    st.Push(2);
    st.Push(3);
    st.Push(4);
    st.Push(5); //1~5까지 데이터 저장
    cout<<st.Pop()<<"\n";
    cout<<st.Pop()<<"\n";
    cout<<st.Pop()<<"\n";
    cout<<st.Pop()<<"\n";
    cout<<st.Pop()<<"\n"; //저장됬던 데이터가 5~1 역순으로 반환
    cout<<st.Pop()<<"\n"; //스택이 비었는대도 반환 요청할경우 언더플로우(-1 출력)
    st.FreeStack(); //스택 파괴
}


```

